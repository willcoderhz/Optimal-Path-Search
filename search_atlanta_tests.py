# coding=utf-8͏︅͏︀͏︋͏︋͏󠄌͏󠄎͏󠄋͏󠄉͏󠄈͏︁

# Author: Mac Chan͏︅͏︀͏︋͏︋͏󠄌͏󠄎͏󠄋͏󠄉͏󠄈͏︁
# Last Updated: 8/25/2023 by Raymond Jia͏︅͏︀͏︋͏︋͏󠄌͏󠄎͏󠄋͏󠄉͏󠄈͏︁

import pickle
import random
import unittest
import networkx

from helpers.explorable_graph import ExplorableGraph
from submission.astar import null_heuristic, euclidean_dist_heuristic
from submission.bi_ucs import bidirectional_ucs
from submission.bi_astar import bidirectional_a_star
from submission.tri_ucs import tridirectional_search
from submission.tri_astar import tridirectional_upgraded
from submission.race import haversine_dist_heuristic
from helpers.visualize_graph import plot_search

class SearchAtlantaTests(unittest.TestCase):
    """
    Error Diagnostic code courtesy one of our former students -  Mac Chan

    The following unit tests will check for random points on atlanta.
    Comment out any tests that you haven't implemented yet.

    If you failed on Gradescope because of non-optimal path, make sure you pass
    all the local tests.
    Change test_count=-1 if you failed the path test on Gradescope, it will run
    tests on atlanta until it finds a set of points that fail.

    If you failed on Gradescope because of your explored set is too large,
    there is no easy way to test without a reference implementation.
    But you can read the pdf slides for the optimized terminal condition.

    To run,
    nosetests --nocapture -v search_atlanta_tests.py:SearchAtlantaTests
    nosetests --nocapture -v search_atlanta_tests.py:SearchAtlantaTests.test_bi_ucs_atlanta
    """

    def setUp(self):
        """Setup both atlanta graph data."""

        with (open("atlanta/atlanta_osm.pickle", "rb")) as atlFile:
            atlanta = pickle.load(atlFile)
        self.atlanta = ExplorableGraph(atlanta)
        self.atlanta.reset_search()

        self.margin_of_error = 1.0e-6

    def reference_path(self, graph, src_node, dst_node, weight='weight'):
        """
        Path as generated by networkx shortest path.

        Args:
            graph (ExplorableGraph): Undirected graph to search.
            src_node (node): Key for the start node.
            dst_node (node): Key for the end node.
            weight (:obj:`str`):
                If None, every edge has weight/distance/cost 1.
                If a string, use this edge attribute as the edge weight.
                Any edge attribute not present defaults to 1.

        Returns:
            Tuple with (cost of path, path as list).
        """

        graph.reset_search()
        if src_node==dst_node:
            cost, path = 0, []
        else:
            path = networkx.shortest_path(graph, src_node, dst_node, weight=weight)
            cost = self.sum_weight(graph, path)

        return cost, path

    @staticmethod
    def sum_weight(graph, path):
        """
        Calculate the total cost of a path by summing edge weights.

        Args:
            graph (ExplorableGraph): Graph that contains path.
            path (list(nodes)): List of nodes from src to dst.

        Returns:
            Sum of edge weights in path.
        """
        pairs = zip(path, path[1:])

        return sum([graph.get_edge_data(a, b)['weight'] for a, b in pairs])

    def run_atlanta_data(self, method, test_count=10, **kwargs):
        """
        Run the bidirectional test search against the Atlanta data.

        In the interest of time and memory, this is not an exhaustive search of
        all possible pairs in the graph.

        Args:
            method (func): Test search function.
            test_count (int): Number of tests to run. Default is 10.
            kwargs: Keyword arguments.

        Asserts:
            True if the path from the test search is equivalent to the
            reference search.
        """

        keys = list(networkx.connected_components(self.atlanta).__next__())
        random.shuffle(keys)
        for src, dst in list(zip(keys, keys[1:]))[::2]:
            self.atlanta.reset_search()
            path = method(self.atlanta, src, dst, **kwargs)
            path_len = self.sum_weight(self.atlanta, path)
            ref_len, ref_path = self.reference_path(self.atlanta, src, dst)
            if abs(path_len - ref_len) > self.margin_of_error:
                print (src, dst)

            self.assertAlmostEqual(path_len, ref_len,
                                   delta=self.margin_of_error)
            test_count -= 1

            if test_count == 0:
                break

    def run_atlanta_tri(self, method, test_count=10, **kwargs):
        """
        Run the tridirectional test search against the Atlanta data.

        In the interest of time and memory, this is not an exhaustive search of
        all possible triplets in the graph.

        Args:
            method (func): Test search function.
            test_count (int): Number of tests to run. Default is 10.
            kwargs: Keyword arguments.

        Asserts:
            True if the path from the test search is equivalent to the
            reference search.
        """

        keys = list(next(networkx.connected_components(self.atlanta)))
        random.shuffle(keys)
        for goals in list(zip(keys, keys[1:], keys[2:]))[::3]:
            self.atlanta.reset_search()
            path = method(self.atlanta, goals, **kwargs)
            path_len = self.sum_weight(self.atlanta, path)
            s1len, _ = self.reference_path(self.atlanta, goals[0], goals[1])
            s2len, _ = self.reference_path(self.atlanta, goals[2], goals[1])
            s3len, _ = self.reference_path(self.atlanta, goals[0], goals[2])
            min_len = min(s1len + s2len, s1len + s3len, s3len + s2len)

            if abs(path_len - min_len) > self.margin_of_error:
                print (goals)
            self.assertAlmostEqual(path_len, min_len,
                                   delta=self.margin_of_error)
            test_count -= 1
            if test_count == 0:
                break

    def test_bi_ucs_atlanta_custom(self):
        """Test and generate GeoJSON for bidirectional UCS search"""
        path = bidirectional_ucs(self.atlanta, '69581003', '69581000')
        all_explored = self.atlanta.explored_nodes()
        plot_search(self.atlanta, 'atlanta_search_bidir_ucs.json', path,
                    all_explored)

    def test_bi_ucs_atlanta(self):
        """
        Test Bi-uniform cost search with Atlanta data.

        To loop test forever, set test_count to -1
        """

        self.run_atlanta_data(bidirectional_ucs, test_count=10)

    def test_bi_a_star_atlanta_custom(self):
        """Test and generate GeoJSON for bidirectional A* search"""
        path = bidirectional_a_star(self.atlanta, '69581003', '69581000', heuristic=haversine_dist_heuristic)
        all_explored = self.atlanta.explored_nodes()
        plot_search(self.atlanta, 'atlanta_search_bidir_a_star.json', path,
                    all_explored)

    def test_bi_a_star_null_atlanta(self):
        """
        Test Bi-A* search with Atlanta data and the Null heuristic.

        To loop test forever, set test_count to -1
        """

        self.run_atlanta_data(bidirectional_a_star, heuristic=null_heuristic,
                              test_count=10)

    def test_bi_a_star_euclidean_atlanta(self):
        """
        Test Bi-A* search with Atlanta data and the Euclidean heuristic.

        To loop test forever, set test_count to -1
        """

        self.run_atlanta_data(bidirectional_a_star,
                              heuristic=euclidean_dist_heuristic,
                              test_count=10)

    def test_bi_a_star_haversine_atlanta(self):
        """
        Test Bi-A* search with Atlanta data and the Haversine heuristic.

        To loop test forever, set test_count to -1
        """

        self.run_atlanta_data(bidirectional_a_star,
                              heuristic=haversine_dist_heuristic,
                              test_count=10)

    def test_tri_ucs_atlanta(self):
        """
        Test Tri-UC search with Atlanta data.

        To loop test forever, set test_count to -1
        """

        self.run_atlanta_tri(tridirectional_search, test_count=10)

    def test_tri_upgraded_null_atlanta(self):
        """
        Test upgraded tri search with Atlanta data and the Null heuristic.

        To loop test forever, set test_count to -1
        """

        self.run_atlanta_tri(tridirectional_upgraded, test_count=10,
                             heuristic=null_heuristic)

    def test_tri_upgraded_euclidean_atlanta(self):
        """
        Test upgraded tri search with Atlanta data and the Euclidean heuristic.

        To loop test forever, set test_count to -1
        """

        self.run_atlanta_tri(tridirectional_upgraded, test_count=10,
                             heuristic=euclidean_dist_heuristic)

    def test_tri_upgraded_haversine_atlanta(self):
        """
        Test upgraded tri search with Atlanta data and the Haversine heuristic.

        To loop test forever, set test_count to -1
        """

        self.run_atlanta_tri(tridirectional_upgraded, test_count=10,
                             heuristic=haversine_dist_heuristic)

if __name__ == '__main__':
    unittest.main()
